<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Art Experience</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
            cursor: none;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }
        .hidden {
            opacity: 0;
        }
        video {
            display: none; /* Videos are used as textures, not visible elements */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="instructions">Press any key to begin</div>
    <!-- Placeholder videos. Replace src with your own video files -->
    <video id="video1" loop crossOrigin="anonymous" src="https://assets.mixkit.co/videos/preview/mixkit-gloomy-forest-in-a-misty-day-4069-large.mp4"></video>
    <video id="video2" loop crossOrigin="anonymous" src="https://assets.mixkit.co/videos/preview/mixkit-waves-in-the-water-1164-large.mp4"></video>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
    import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

    // --- Configuration -----------------------------------------------
    const CONFIG = {
        START_TEXT: 'START',
        TIMER_DURATION: 15000, // in milliseconds
        PARTICLE_SPEED: 0.05,
        CAMERA_Z: 5,
        PANEL_ASPECT: 16 / 9,
        PANEL_WIDTH: 3,
        PANEL_GAP: 0.5,
        BLOOM_PARAMS: {
            strength:0.75,
            radius: 0.6,
            threshold: 0.1,
        }
    };

    // --- Main Application Class --------------------------------------
    class ArtExperience {
        constructor() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.clock = new THREE.Clock();

            this.composer = null;
            this.bloomPass = null;
            this.filmPass = null;

            this.state = 'intro'; // intro -> dissolving -> selection -> playing
            this.selectedPanel = 'left';
            this.timer = {
                startTime: 0,
                remaining: CONFIG.TIMER_DURATION,
                active: false
            };

            this.startText = null;
            this.particles = null;
            this.panels = { left: null, right: null };
            this.timerBar = null;
            
            this.instructions = document.getElementById('instructions');

            this.init();
        }

        init() {
            // Renderer setup
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(this.renderer.domElement);

            // Camera setup
            this.camera.position.z = CONFIG.CAMERA_Z;

            // Post-processing
            this.initPostProcessing();

            // Load assets
            this.loadAssets();

            // Event listeners
            window.addEventListener('resize', this.onWindowResize.bind(this), false);
            window.addEventListener('keydown', this.onKeyPress.bind(this), { once: true }); // Only fires once to start
            
            this.animate();
        }

        initPostProcessing() {
            const renderPass = new RenderPass(this.scene, this.camera);
            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(renderPass);

            // Bloom for glow effect
            this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 
                CONFIG.BLOOM_PARAMS.strength, 
                CONFIG.BLOOM_PARAMS.radius, 
                CONFIG.BLOOM_PARAMS.threshold
            );
            this.composer.addPass(this.bloomPass);
            
            // Film pass for glitch/scanline effect
            this.filmPass = new FilmPass(0.35, 0.5, 2048, false);
            this.composer.addPass(this.filmPass);

            // Prism/Chromatic Aberration Shader
            const chromaticAberrationShader = {
                uniforms: {
                    'tDiffuse': { value: null },
                    'amount': { value: 0.005 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float amount;
                    varying vec2 vUv;
                    void main() {
                        vec2 offset = amount * vec2(cos(vUv.y * 10.0), sin(vUv.x * 10.0));
                        vec4 r = texture2D(tDiffuse, vUv + offset);
                        vec4 g = texture2D(tDiffuse, vUv);
                        vec4 b = texture2D(tDiffuse, vUv - offset);
                        gl_FragColor = vec4(r.r, g.g, b.b, g.a);
                    }
                `
            };
            const chromaticPass = new ShaderPass(chromaticAberrationShader);
            this.composer.addPass(chromaticPass);
        }

        loadAssets() {
            const fontLoader = new FontLoader();
            // Using a built-in Three.js font for simplicity
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                this.createStartText(font);
            });
        }

        createStartText(font) {
            const geometry = new TextGeometry(CONFIG.START_TEXT, {
                font: font,
                size: 1,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
            });
            geometry.center();
            
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            this.startText = new THREE.Mesh(geometry, material);
            this.scene.add(this.startText);
        }

        dissolveText() {
            if (!this.startText) return;
            
            const textGeometry = this.startText.geometry;
            const count = 5000;
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            
            const sampler = new MeshSurfaceSampler(this.startText).build();
            const _position = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                sampler.sample(_position);
                positions.set([_position.x, _position.y, _position.z], i * 3);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(CONFIG.PARTICLE_SPEED * (Math.random() * 0.5 + 0.5));
                velocities.set([velocity.x, velocity.y, velocity.z], i * 3);
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02,
                transparent: true,
                opacity: 1.0
            });

            this.particles = new THREE.Points(particleGeometry, particleMaterial);
            this.scene.add(this.particles);

            this.scene.remove(this.startText);
            this.startText.geometry.dispose();
            this.startText.material.dispose();
            this.startText = null;

            this.state = 'dissolving';
            setTimeout(() => {
                this.createPanels();
                this.state = 'selection';
                this.timer.active = true;
                this.timer.startTime = this.clock.getElapsedTime();
                window.addEventListener('keydown', this.onSelectionKeyPress.bind(this));
            }, 2000); // Wait for particles to clear
        }
        
        createPanels() {
            const video1 = document.getElementById('video1');
            const video2 = document.getElementById('video2');
            video1.play().catch(e => console.error("Video play failed:", e));
            video2.play().catch(e => console.error("Video play failed:", e));
            video1.pause();
            video2.pause();

            const panelHeight = CONFIG.PANEL_WIDTH / CONFIG.PANEL_ASPECT;
            const geometry = new THREE.PlaneGeometry(CONFIG.PANEL_WIDTH, panelHeight, 32, 32);

            const createPanel = (video, positionX) => {
                const texture = new THREE.VideoTexture(video);
                texture.needsUpdate = true;
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        tDiffuse: { value: texture },
                        borderColor: { value: new THREE.Color(0x00ffff) },
                        borderWidth: { value: 0.03 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform sampler2D tDiffuse;
                        uniform vec3 borderColor;
                        uniform float borderWidth;
                        varying vec2 vUv;

                        void main() {
                            vec4 texColor = texture2D(tDiffuse, vUv);
                            
                            float border = smoothstep(0.0, borderWidth, vUv.x) * (1.0 - smoothstep(1.0 - borderWidth, 1.0, vUv.x)) *
                                           smoothstep(0.0, borderWidth, vUv.y) * (1.0 - smoothstep(1.0 - borderWidth, 1.0, vUv.y));

                            float speed = 2.0;
                            float hue = mod(time * speed + vUv.x + vUv.y, 1.0);
                            vec3 gradientColor = hsv2rgb(vec3(hue, 1.0, 1.0));

                            if (border < 0.5) {
                                gl_FragColor = vec4(gradientColor, 1.0);
                            } else {
                                gl_FragColor = texColor;
                            }
                        }
                        
                        vec3 hsv2rgb(vec3 c) {
                            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                        }
                    `
                });

                const panel = new THREE.Mesh(geometry, material);
                panel.position.x = positionX;
                this.scene.add(panel);
                return panel;
            };

            const panelX = (CONFIG.PANEL_WIDTH / 2) + CONFIG.PANEL_GAP;
            this.panels.left = createPanel(video1, -panelX);
            this.panels.right = createPanel(video2, panelX);
            this.panels.left.video = video1;
            this.panels.right.video = video2;

            this.createTimerBar();
        }

        createTimerBar() {
            const barWidth = (CONFIG.PANEL_WIDTH + CONFIG.PANEL_GAP) * 2;
            const barHeight = 0.05;
            const geometry = new THREE.PlaneGeometry(barWidth, barHeight);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            this.timerBar = new THREE.Mesh(geometry, material);
            
            const panelHeight = CONFIG.PANEL_WIDTH / CONFIG.PANEL_ASPECT;
            this.timerBar.position.y = (panelHeight / 2) + 0.2;
            this.scene.add(this.timerBar);
        }

        playSelectedVideo() {
            this.state = 'playing';
            this.timer.active = false;
            
            const selected = this.panels[this.selectedPanel];
            const unselected = this.panels[this.selectedPanel === 'left' ? 'right' : 'left'];

            // Animate fade out of unselected elements
            [unselected, this.timerBar].forEach(obj => {
                if (obj) {
                    const material = obj.material.isShaderMaterial ? obj.material.uniforms.tDiffuse.value : obj.material;
                    if(material) material.transparent = true;
                    this.fadeOut(obj.material);
                }
            });
            
            // Animate camera and panel
            this.zoomToPanel(selected);

            selected.video.play();
            this.instructions.classList.add('hidden');
        }

        zoomToPanel(panel) {
            const targetPosition = panel.position.clone();
            targetPosition.z = this.camera.position.z - 2; 

            // Simple tweening logic
            const duration = 1.5; // seconds
            const startPos = this.camera.position.clone();
            const endPos = new THREE.Vector3(panel.position.x, panel.position.y, this.camera.position.z);
            const startScale = panel.scale.clone();
            const endScale = new THREE.Vector3(2.5, 2.5, 2.5); // Adjust for full screen
            
            const startTime = this.clock.getElapsedTime();
            
            const tween = () => {
                const elapsedTime = this.clock.getElapsedTime() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                this.camera.position.lerpVectors(startPos, endPos, progress);
                panel.scale.lerpVectors(startScale, endScale, progress);
                
                if (progress < 1) requestAnimationFrame(tween);
            };
            tween();
        }

        fadeOut(material, duration = 1) {
             const startTime = this.clock.getElapsedTime();
             const startOpacity = material.opacity || (material.uniforms ? material.uniforms.opacity.value : 1.0);
             
             const fade = () => {
                const elapsedTime = this.clock.getElapsedTime() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                const newOpacity = THREE.MathUtils.lerp(startOpacity, 0, progress);

                if (material.isShaderMaterial) {
                   // This simple fade won't work on the custom shader without modification
                   // For now, we just remove it
                   if(progress >= 1 && material.parent) this.scene.remove(material.parent);
                } else {
                    material.opacity = newOpacity;
                    if(progress >= 1 && material.parent) this.scene.remove(material.parent);
                }

                if (progress < 1) requestAnimationFrame(fade);
             }
             fade();
        }

        // --- Event Handlers ----------------------------------------------
        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        }

        onKeyPress(event) {
            if (this.state === 'intro') {
                this.dissolveText();
                this.instructions.textContent = "Use ← and → to choose. Press Enter to select.";
            }
        }
        
        onSelectionKeyPress(event) {
            if (this.state !== 'selection') return;

            if (event.key === 'ArrowLeft') {
                this.selectedPanel = 'left';
            } else if (event.key === 'ArrowRight') {
                this.selectedPanel = 'right';
            } else if (event.key === 'Enter') {
                this.playSelectedVideo();
            }
        }

        // --- Animation Loop ---------------------------------------------
        animate() {
            requestAnimationFrame(this.animate.bind(this));
            const delta = this.clock.getDelta();
            const elapsedTime = this.clock.getElapsedTime();
            
            // Intro animation
            if (this.state === 'intro' && this.startText) {
                this.startText.position.y = Math.sin(elapsedTime * 1.5) * 0.1;
                this.filmPass.uniforms['time'].value += delta;
                this.bloomPass.strength = CONFIG.BLOOM_PARAMS.strength + Math.sin(elapsedTime * 5) * 0.1 - 0.2;
            }

            // Dissolving animation
            if (this.state === 'dissolving' && this.particles) {
                const positions = this.particles.geometry.attributes.position;
                const velocities = this.particles.geometry.attributes.velocity;
                for (let i = 0; i < positions.count; i++) {
                    positions.setX(i, positions.getX(i) + velocities.getX(i));
                    positions.setY(i, positions.getY(i) + velocities.getY(i));
                    positions.setZ(i, positions.getZ(i) + velocities.getZ(i));
                }
                positions.needsUpdate = true;
                this.particles.material.opacity -= 0.005;
                if (this.particles.material.opacity <= 0) {
                    this.scene.remove(this.particles);
                    this.particles.geometry.dispose();
                    this.particles.material.dispose();
                    this.particles = null;
                }
            }

            // Selection animation
            if (this.state === 'selection') {
                // Timer logic
                if (this.timer.active) {
                    this.timer.remaining = Math.max(0, CONFIG.TIMER_DURATION - (elapsedTime - this.timer.startTime) * 1000);
                    const progress = this.timer.remaining / CONFIG.TIMER_DURATION;
                    
                    if (this.timerBar) {
                        this.timerBar.scale.x = progress;
                        this.timerBar.position.x = -(1 - progress) * (this.timerBar.geometry.parameters.width / 2);
                        
                        // Color interpolation
                        const green = new THREE.Color(0x00ff00);
                        const yellow = new THREE.Color(0xffff00);
                        const red = new THREE.Color(0xff0000);
                        if (progress > 0.5) {
                            this.timerBar.material.color.lerpColors(yellow, green, (progress - 0.5) * 2);
                        } else {
                            this.timerBar.material.color.lerpColors(red, yellow, progress * 2);
                        }
                    }

                    if (this.timer.remaining === 0) {
                        this.timer.active = false;
                        this.playSelectedVideo(); // Auto-select if time runs out
                    }
                }
                
                // Panel animation
                Object.keys(this.panels).forEach(key => {
                    const panel = this.panels[key];
                    if (panel) {
                        panel.position.y = Math.sin(elapsedTime * 0.8 + (key === 'left' ? Math.PI : 0)) * 0.1;
                        panel.rotation.y = Math.sin(elapsedTime * 0.5 + (key === 'left' ? Math.PI : 0)) * 0.05;
                        panel.material.uniforms.time.value = elapsedTime;
                        
                        // Highlight selected
                        const targetScale = (key === this.selectedPanel) ? 1.1 : 1.0;
                        panel.scale.lerp(new THREE.Vector3(targetScale, targetScale, 1), 0.1);
                    }
                });
            }

            // Update video textures if playing
            if(this.state === 'playing') {
                const selected = this.panels[this.selectedPanel];
                if(selected && selected.video.readyState >= selected.video.HAVE_CURRENT_DATA) {
                    selected.material.uniforms.tDiffuse.value.needsUpdate = true;
                }
            }

            this.composer.render(delta);
        }
    }

    new ArtExperience();

    </script>
</body>
</html>

